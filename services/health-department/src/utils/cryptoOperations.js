import argon2 from 'argon2-browser';
import moment from 'moment';

import {
  createLocationTransfer,
  createUserTransfer,
  getCurrentDailyKey,
  getEncryptedUserContactData,
  getUserTraces,
  getUserTransferById,
  getUserTransferByTan,
  getMe,
} from 'network/api';

import {
  base32CrockfordToHex,
  base64ToHex,
  bytesToHex,
  bytesToUint8Array,
  DECRYPT_DLIES,
  ENCRYPT_DLIES,
  GENERATE_TRACE_ID,
  hexToBase64,
  hexToBytes,
  hexToUuid,
  hexToUuid4,
  HKDF_SHA256,
  int32ToHex,
  KDF_SHA256,
} from '@lucaapp/crypto';

import {
  getDailyPrivateKey,
  signLocationTransfer,
} from './cryptoKeyOperations';
import {
  decryptAdditionalData,
  decryptDynamicDeviceTrace,
  decryptStaticDeviceTrace,
  decryptUser,
} from './decryption';
import { sanitizeObject } from './sanitizer';
import { QR_V3, QR_V4 } from '../constants/qrVersion';

const STATIC_DEVICE_TYPE = 2;

const ARGON_SALT = 'da3ae5ecd280924e';
const L1_INFO = bytesToHex('badge_crypto_assets');
const L2_INFO = bytesToHex('badge_tracing_assets');

export const EMPTY_HISTORY = 'EMPTY_HISTORY';
export const INVALID_VERSION = 'INVALID_VERSION';
export const DECRYPTION_FAILED = 'DECRYPTION_FAILED';

/**
 * Decrypts a guest data transfer object using the corresponding daily private
 * key, to obtain the contact data of the guest.
 *
 * @param userTransferId - The id of the user transfer (not the tan)
 * @returns Contact data of the guest
 */
export const decryptUserTransfer = async userTransferId => {
  try {
    // also referred to as guest data transfer object
    const userDataTransferObject = await getUserTransferById(userTransferId);
    const dailyPrivateKey = await getDailyPrivateKey(
      userDataTransferObject.keyId
    );
    const userSecrets = JSON.parse(
      hexToBytes(
        DECRYPT_DLIES(
          dailyPrivateKey,
          base64ToHex(userDataTransferObject.publicKey),
          base64ToHex(userDataTransferObject.data),
          base64ToHex(userDataTransferObject.iv),
          base64ToHex(userDataTransferObject.mac)
        )
      )
    );

    const userId = userSecrets.uid;
    const userDataSecret = base64ToHex(userSecrets.uds);
    const encryptedUser = await getEncryptedUserContactData(userId);

    const userDataEncryptionKey =
      userSecrets.qrv === QR_V4
        ? base64ToHex(userSecrets.uds)
        : KDF_SHA256(userDataSecret, '01').slice(0, 32);

    const { userData } = decryptUser(encryptedUser, userDataEncryptionKey);

    return { ...userData, uuid: userId };
  } catch (error) {
    console.error('Error in decryptUserTransfer:', error);
    throw error;
  }
};

/**
 * First decrypts the encrypted data secret and user id attached to a trace
 * (ensuring authenticity), then fetches the corresponding encrypted personal
 * data using the user id and decrypts it by deriving the data key from the
 * data secret. If there is additional data associated with the trace it will
 * also be decrypted.
 *
 * @see https://www.luca-app.de/securityoverview/processes/tracing_find_contacts.html#process
 * @param encryptedTrace - A trace containing an encrypted data secret and user id
 * @returns Decrypted trace with user and additional data
 */
export const decryptTrace = async encryptedTrace => {
  try {
    const isStaticDevice = encryptedTrace.deviceType === STATIC_DEVICE_TYPE;

    const { userData, isInvalid } = isStaticDevice
      ? await decryptStaticDeviceTrace(encryptedTrace)
      : await decryptDynamicDeviceTrace(encryptedTrace);

    const additionalData = decryptAdditionalData(encryptedTrace, isInvalid);
    // sanitize data here

    return {
      traceId: encryptedTrace.traceId,
      checkin: encryptedTrace.checkin,
      checkout: encryptedTrace.checkout,
      deviceType: encryptedTrace.deviceType,
      userData: sanitizeObject(userData),
      additionalData: sanitizeObject(additionalData),
      isInvalid,
    };
  } catch (error) {
    console.error('Error in decryptTrace', error);
    throw error;
  }
};

/**
 * Based on a userId and userTracingSecret, this function returns a list of
 * traceIds for a specified number of days, starting at start. These traceIds
 * will overlap with those generated by the end user apps, provided the input
 * parameters are the same and the timestamps overlap.
 * @param userId Input to GENERATE_TRACE_ID
 * @param userTracingSecret Input to GENERATE_TRACE_ID
 * @param start UNIX timestamp to start trace generation from. Per convention,
 * this should be a full minute (at 0 seconds).
 * @param days Number of days to calculate traceIds for
 * @returns {string[]} traceIds
 */
const calculateTraceIds = (userId, userTracingSecret, start, days) => {
  const traceIds = [];
  const minutesToCalculate = days * 24 * 60;
  for (let minute = 0; minute < minutesToCalculate; minute += 1) {
    const traceId = GENERATE_TRACE_ID(
      userId + int32ToHex(start + 60 * minute),
      userTracingSecret
    );
    traceIds.push(traceId);
  }
  return traceIds;
};

const getUserTracesV2 = (userSecrets, userId) => {
  const start = moment().seconds(0).subtract(14, 'days').unix();
  const userTracingSecret = base64ToHex(userSecrets.uts);
  const traceIds = calculateTraceIds(userId, userTracingSecret, start, 14);
  return getUserTraces({
    traceIds,
  });
};

const getUserTracesV3 = (userSecrets, userId) => {
  const traceIds = userSecrets.uts.flatMap(({ ts, s }) =>
    calculateTraceIds(userId, base64ToHex(s), ts, 1)
  );
  return getUserTraces({
    traceIds,
  });
};

/**
 * Starts the process of reconstructing the check-in history of a guest. The
 * guest data transfer object identified by the given tan is fetched and
 * decrypted with the corresponding daily private key. The user tracing secret
 * is then provided to the server to create a location transfer process for
 * all affected check-ins.
 *
 * @see https://www.luca-app.de/securityoverview/processes/tracing_access_to_history.html#reconstructing-the-infected-guest-s-check-in-history
 * @param tan - Transaction number provided by the user
 * @param lang - Language of the notification process
 * @returns Id of the tracing process
 */
export const initiateUserTracingProcess = async (tan, lang) => {
  try {
    // also referred to as guest data transfer object
    const userDataTransferObject = await getUserTransferByTan(tan);
    const dailyPrivateKey = await getDailyPrivateKey(
      userDataTransferObject.keyId
    );
    if (!dailyPrivateKey) {
      console.error('invalid dailyPrivateKey');
    }

    let userSecrets;
    try {
      userSecrets = JSON.parse(
        hexToBytes(
          DECRYPT_DLIES(
            dailyPrivateKey,
            base64ToHex(userDataTransferObject.publicKey),
            base64ToHex(userDataTransferObject.data),
            base64ToHex(userDataTransferObject.iv),
            base64ToHex(userDataTransferObject.mac)
          )
        )
      );
    } catch {
      return DECRYPTION_FAILED;
    }

    let userTraces;
    const userId = userSecrets.uid.replace(/-/g, '');
    switch (userSecrets.v) {
      case 2:
        userTraces = await getUserTracesV2(userSecrets, userId);
        break;
      case 3:
        userTraces = await getUserTracesV3(userSecrets, userId);
        break;
      default:
        return INVALID_VERSION;
    }

    if (userTraces.length === 0) {
      return EMPTY_HISTORY;
    }

    const healthDepartmentUUID = await getMe().then(
      response => response.departmentId
    );

    const userTracesWithSignature = userTraces.map(userTrace => ({
      ...userTrace,
      signedLocationTransfer: signLocationTransfer({
        locationId: userTrace.locationId,
        time: userTrace.time,
        iss: healthDepartmentUUID,
      }),
    }));
    const { tracingProcessId } = await createLocationTransfer({
      locations: userTracesWithSignature,
      userTransferId: userDataTransferObject.uuid,
      lang,
    });

    return tracingProcessId;
  } catch (error) {
    console.error('Error in initiateUserTracingProcess:', error);
    throw error;
  }
};

const isStaticV3 = serialNumber => {
  return (
    serialNumber.toLowerCase().endsWith('0') ||
    serialNumber.toLowerCase().endsWith('g')
  );
};

const isStaticV4 = serialNumber => {
  return (
    serialNumber.toLowerCase().endsWith('2') ||
    serialNumber.toLowerCase().endsWith('h')
  );
};

/**
 * Initiates the process of reconstructing the check-in history of a user
 * of a static badge. Requires the badge's serial number and creates a guest
 * data transfer object and tan for the guest. Then continues with the regular
 * initiateUserTracingProcess.
 *
 * @param serialNumber - Serial number of the static badge
 * @param lang - Language of the notification process
 * @returns Id of the tracing process
 */
export const initiateStaticUserTracingProcess = async (serialNumber, lang) => {
  try {
    let userId;
    let userDataSecret;
    let userTracingSecret;
    let qrVersion;

    if (isStaticV3(serialNumber)) {
      qrVersion = QR_V3;
      const entropy = base32CrockfordToHex(serialNumber);

      userDataSecret = KDF_SHA256(entropy, '01');
      const tracingSeed = KDF_SHA256(entropy, '02').slice(0, 32);

      const rawUserId = KDF_SHA256(tracingSeed, '01').slice(0, 32);
      userTracingSecret = KDF_SHA256(tracingSeed, '03').slice(0, 32);

      const hexUserId = `${rawUserId.slice(0, 8)}f${rawUserId.slice(9, 32)}`;
      userId = hexToUuid(hexUserId);
    } else if (isStaticV4(serialNumber)) {
      qrVersion = QR_V4;
      const realSerialNumber = serialNumber
        .toLowerCase()
        .replace(/h$/, 'g')
        .replace(/2$/, '0');
      const entropy = base32CrockfordToHex(realSerialNumber);

      const argon2hash = await argon2.hash({
        pass: bytesToUint8Array(hexToBytes(entropy)),
        salt: ARGON_SALT,
        time: 11,
        mem: 32 * 1024,
        hashLen: 16,
        parallelism: 1,
        type: argon2.ArgonType.Argon2id,
      });

      const seed = argon2hash.hashHex;

      const l1 = await HKDF_SHA256(seed, 64, L1_INFO, '');
      userDataSecret = l1.slice(0, 32);
      const tracingSeed = l1.slice(32, 64);

      const l2 = await HKDF_SHA256(tracingSeed, 48, L2_INFO, '');

      const rawUserId = l2.slice(0, 32);
      userTracingSecret = l2.slice(64, 96);

      const hexUserId = hexToUuid4(rawUserId);
      userId = hexToUuid(hexUserId);
    }

    // create user transfer
    const userSecrets = {
      v: 2,
      qrv: qrVersion,
      uid: userId,
      uds: hexToBase64(userDataSecret),
      uts: hexToBase64(userTracingSecret),
    };

    const dailyKey = await getCurrentDailyKey();

    const userTransferData = ENCRYPT_DLIES(
      base64ToHex(dailyKey.publicKey),
      bytesToHex(JSON.stringify(userSecrets))
    );

    const { tan } = await createUserTransfer({
      data: hexToBase64(userTransferData.data),
      iv: hexToBase64(userTransferData.iv),
      mac: hexToBase64(userTransferData.mac),
      publicKey: hexToBase64(userTransferData.publicKey),
      keyId: dailyKey.keyId,
    });

    return initiateUserTracingProcess(tan, lang);
  } catch (error) {
    console.error('Error in initiateStaticUserTracingProcess:', error);
    throw error;
  }
};
